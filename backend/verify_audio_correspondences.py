#!/usr/bin/env python3
"""
Script de v√©rification approfondie des correspondances audio
Analyse les orthographes compl√®tes des mots et de leurs prononciations originales
"""

import os
import sys
from datetime import datetime
from dotenv import load_dotenv
from pymongo import MongoClient

# Charger les variables d'environnement
load_dotenv()

def verify_audio_correspondences():
    """V√©rifier toutes les correspondances audio avec analyse orthographique."""
    
    try:
        # Connexion √† MongoDB
        mongo_url = os.getenv('MONGO_URL', 'mongodb://localhost:27017/')
        client = MongoClient(mongo_url)
        db_name = os.getenv('DB_NAME', 'mayotte_app')
        db = client[db_name]
        collection = db.words
        
        print("üîç V√âRIFICATION APPROFONDIE DES CORRESPONDANCES AUDIO")
        print("=" * 80)
        print("Analyse des orthographes compl√®tes des mots et prononciations")
        print()
        
        # Traiter chaque cat√©gorie
        categories = ['famille', 'nature', 'nombres', 'animaux']
        total_errors = 0
        total_words = 0
        
        for category in categories:
            print(f"üìÇ ANALYSE CAT√âGORIE: {category.upper()}")
            print("-" * 60)
            
            # R√©cup√©rer tous les mots de cette cat√©gorie avec syst√®me dual
            category_words = list(collection.find({
                "category": category, 
                "dual_audio_system": True
            }))
            
            if not category_words:
                print(f"‚ö†Ô∏è Aucun mot avec syst√®me dual trouv√© pour {category}")
                continue
            
            # Lister les fichiers audio disponibles
            audio_dir = f"/app/frontend/assets/audio/{category}"
            available_files = []
            if os.path.exists(audio_dir):
                available_files = [f for f in os.listdir(audio_dir) if f.endswith('.m4a')]
            
            print(f"üìù {len(category_words)} mots avec syst√®me dual")
            print(f"üéµ {len(available_files)} fichiers audio disponibles")
            print()
            
            # Analyser chaque mot
            category_errors = 0
            for word in category_words:
                total_words += 1
                french = word.get('french', 'N/A')
                shimaore = word.get('shimaore', 'N/A')
                kibouchi = word.get('kibouchi', 'N/A')
                
                shimoare_file = word.get('shimoare_audio_filename')
                kibouchi_file = word.get('kibouchi_audio_filename')
                
                word_errors = []
                
                print(f"üî∏ **{french}**")
                print(f"   Shimaor√©: '{shimaore}'")
                print(f"   Kibouchi: '{kibouchi}'")
                
                # V√©rifier correspondance Shimaor√©
                if shimoare_file:
                    print(f"   üìÅ Audio Shimaor√©: {shimoare_file}")
                    
                    # V√©rifier si le fichier existe
                    if shimoare_file not in available_files:
                        word_errors.append(f"Fichier shimaor√© {shimoare_file} INTROUVABLE")
                    else:
                        # Analyser la correspondance orthographique
                        base_filename = shimoare_file.replace('.m4a', '').lower()
                        shimaore_clean = shimaore.lower().replace(' ', '').replace('/', '').replace('-', '').replace("'", "")
                        
                        # V√©rifications de correspondance stricte
                        if (base_filename != shimaore_clean and 
                            shimaore_clean not in base_filename and 
                            base_filename not in shimaore_clean):
                            
                            # V√©rifications additionnelles pour les cas sp√©ciaux
                            special_cases = check_special_cases(french, shimaore, shimoare_file, category)
                            if not special_cases:
                                word_errors.append(f"SHIMAOR√â: '{shimaore}' ‚â† fichier '{shimoare_file}' (base: {base_filename})")
                else:
                    print(f"   ‚ùå Pas d'audio shimaor√©")
                
                # V√©rifier correspondance Kibouchi
                if kibouchi_file:
                    print(f"   üìÅ Audio Kibouchi: {kibouchi_file}")
                    
                    # V√©rifier si le fichier existe
                    if kibouchi_file not in available_files:
                        word_errors.append(f"Fichier kibouchi {kibouchi_file} INTROUVABLE")
                    else:
                        # Analyser la correspondance orthographique
                        base_filename = kibouchi_file.replace('.m4a', '').lower()
                        kibouchi_clean = kibouchi.lower().replace(' ', '').replace('/', '').replace('-', '').replace("'", "")
                        
                        # V√©rifications de correspondance stricte
                        if (base_filename != kibouchi_clean and 
                            kibouchi_clean not in base_filename and 
                            base_filename not in kibouchi_clean):
                            
                            # V√©rifications additionnelles pour les cas sp√©ciaux
                            special_cases = check_special_cases(french, kibouchi, kibouchi_file, category)
                            if not special_cases:
                                word_errors.append(f"KIBOUCHI: '{kibouchi}' ‚â† fichier '{kibouchi_file}' (base: {base_filename})")
                else:
                    print(f"   ‚ùå Pas d'audio kibouchi")
                
                # Afficher les erreurs trouv√©es
                if word_errors:
                    print(f"   üö® **ERREURS D√âTECT√âES** ({len(word_errors)}):")
                    for error in word_errors:
                        print(f"     ‚û§ {error}")
                    category_errors += len(word_errors)
                    total_errors += len(word_errors)
                else:
                    print(f"   ‚úÖ Correspondances correctes")
                
                print()
            
            print(f"üìä Cat√©gorie {category}: {category_errors} erreurs d√©tect√©es")
            print()
        
        # R√©sum√© final
        print("=" * 80)
        print(f"üìà R√âSUM√â DE LA V√âRIFICATION")
        print(f"üîç Total mots analys√©s: {total_words}")
        print(f"üö® Total erreurs d√©tect√©es: {total_errors}")
        
        if total_errors == 0:
            print("‚úÖ Toutes les correspondances sont correctes!")
        else:
            print("‚ö†Ô∏è Des corrections sont n√©cessaires")
        
        # Proposer des fichiers audio non utilis√©s
        print("\nüìã ANALYSE DES FICHIERS AUDIO NON UTILIS√âS")
        print("-" * 60)
        
        for category in categories:
            audio_dir = f"/app/frontend/assets/audio/{category}"
            if not os.path.exists(audio_dir):
                continue
                
            available_files = [f for f in os.listdir(audio_dir) if f.endswith('.m4a')]
            
            # R√©cup√©rer les fichiers utilis√©s
            used_files = set()
            category_words = list(collection.find({
                "category": category, 
                "dual_audio_system": True
            }))
            
            for word in category_words:
                shimoare_file = word.get('shimoare_audio_filename')
                kibouchi_file = word.get('kibouchi_audio_filename')
                if shimoare_file:
                    used_files.add(shimoare_file)
                if kibouchi_file:
                    used_files.add(kibouchi_file)
            
            unused_files = set(available_files) - used_files
            
            print(f"\nüéµ {category.upper()}:")
            print(f"   Total fichiers: {len(available_files)}")
            print(f"   Fichiers utilis√©s: {len(used_files)}")
            print(f"   Fichiers non utilis√©s: {len(unused_files)}")
            
            if unused_files:
                print(f"   üìÅ Fichiers disponibles non utilis√©s:")
                for unused in sorted(unused_files):
                    print(f"     ‚Ä¢ {unused}")
        
        client.close()
        return total_errors == 0
        
    except Exception as e:
        print(f"‚ùå Erreur: {str(e)}")
        import traceback
        traceback.print_exc()
        return False

def check_special_cases(french, local_word, audio_file, category):
    """V√©rifier les cas sp√©ciaux de correspondance"""
    
    # Cas sp√©ciaux connus
    special_mappings = {
        'famille': {
            # Cas o√π le m√™me fichier est utilis√© pour les deux langues
            ('baba', 'Baba k.m4a'): True,  # papa en shimaor√© mais fichier k
            ('baba', 'Baba s.m4a'): True,  # papa en kibouchi mais fichier s
        },
        'nature': {
            # Cas o√π les traductions sont identiques
            ('bahari', 'Bahari.m4a'): True,  # mer identique dans les deux langues
            ('cal√©ni', 'Cal√©ni.m4a'): True,  # barri√®re de corail identique
        },
        'nombres': {
            # Cas sp√©ciaux de nombres
            ('moja', 'Moja.m4a'): True,
            ('areki', 'Areki.m4a'): True,
        },
        'animaux': {
            # Cas d'animaux avec variations
            ('simba', 'Simba.m4a'): True,  # lion identique dans les deux langues
        }
    }
    
    # V√©rifier les mappings sp√©ciaux pour la cat√©gorie
    category_mappings = special_mappings.get(category, {})
    local_word_lower = local_word.lower()
    
    for (word, file), is_valid in category_mappings.items():
        if word.lower() == local_word_lower and audio_file == file:
            return is_valid
    
    # V√©rifications additionnelles g√©n√©riques
    
    # 1. Fichiers avec suffixes 's' ou 'k' (shimaor√©/kibouchi)
    if audio_file.endswith(' s.m4a') or audio_file.endswith(' k.m4a'):
        base_file = audio_file.replace(' s.m4a', '').replace(' k.m4a', '').lower()
        if base_file in local_word_lower or local_word_lower in base_file:
            return True
    
    # 2. Correspondances partielles acceptables
    audio_base = audio_file.replace('.m4a', '').lower()
    word_parts = local_word_lower.replace(' ', '').replace('/', '').replace('-', '').replace("'", "")
    
    # Si une partie significative correspond (>= 4 caract√®res)
    if len(word_parts) >= 4:
        if word_parts in audio_base or audio_base in word_parts:
            return True
    
    # 3. Cas de mots compos√©s
    if ' ' in local_word or '/' in local_word:
        parts = local_word.lower().replace('/', ' ').split()
        for part in parts:
            part_clean = part.replace("'", "").replace("-", "")
            if len(part_clean) >= 3 and (part_clean in audio_base or audio_base in part_clean):
                return True
    
    return False

if __name__ == "__main__":
    print("üöÄ V√âRIFICATION APPROFONDIE DES CORRESPONDANCES AUDIO")
    print("üéØ Analyse orthographique compl√®te des mots et prononciations")
    print()
    
    success = verify_audio_correspondences()
    
    if success:
        print("üéâ V√©rification termin√©e - Aucune erreur d√©tect√©e!")
    else:
        print("‚ö†Ô∏è V√©rification termin√©e - Des corrections sont n√©cessaires")